

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}


console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}


console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}

console.log("Hello, World!");


// Simple chunking by characters (good enough to start).
// Later you can replace with token-based chunking.
export function chunkText(
  text: string,
  chunkSize = 1500,
  overlap = 200,
): string[] {
  const cleaned = text.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  let i = 0;

  while (i < cleaned.length) {
    chunks.push(cleaned.slice(i, i + chunkSize));
    i += Math.max(1, chunkSize - overlap);
  }
  return chunks.filter((c) => c.trim().length > 0);
}
